# 单例模式

## 使用场景

单例模式出现的目的是保证系统只有一个实例对象，而且提供一个全局的访问点。

在下面几个场景中适合使用单例模式:

1. 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。
2. 控制资源的情况下，方便资源之间的互相通信。如线程池等。

## 常见的几种单例模式

1. 懒汉式

   ```java
   package com.cbl;
   
   /**
    * @author ：CBL
    * @date ：Created in 2020/1/9  21:01
    * @description：
    */
   public class LazySingle {
   
       /**
        * 私有化构造方法,防止外部直接创建(但是反射可以)
        */
       private LazySingle() {
       }
   
       
       private static LazySingle lazySingle=null;
   
       /**
        * @Description: 对外提供获取实例的方法
        * @param:
        * @return: com.cbl.LazySingle
        * @Author: CBL
        * @Date: 2020/1/9 21:07
        */
       public static LazySingle getSingle(){
         if (lazySingle==null){
   ·      }
         return lazySingle;
       }
   }
   ```

   **不建议使用** ,缺点如下：

   1. getSingle方法是线程不安全的，多线程的情况下，可以创建多个。

   2. 反射可以直接创建这个类的对象，。

      ```java
      package com.cbl;
      
      import java.lang.reflect.Constructor;
      
      /**
       * @author ：CBL
       * @date ：Created in 2020/1/9  21:00
       * @description：
       */
      public class singleTest {
      
      
          public static void main(String[] args)throws Exception {
              LazySingle single = LazySingle.getSingle();
              LazySingle singl1 = LazySingle.getSingle();
              Constructor<LazySingle> constructor=LazySingle.class.getDeclaredConstructor();
              //2.设置取消访问检查，是访问私有构造方法的关键
              constructor.setAccessible(true);
              //3.调用该构造方法，获得对象
              LazySingle reflectSingle = constructor.newInstance();
              if (single==singl1){
                  System.out.println("通过懒汉式获取的对象一样");
              }else{
                  System.out.println("通过懒汉式获取的对象不一样");
              }
              if (single==reflectSingle){
                  System.out.println("反射获取的对象一样");
              }else{
                  System.out.println("反射获取的对象不一样");
              }
      
          }
          
      }
      ```

      返回结果为：

      ```
      通过懒汉式获取的对象一样
      反射获取的对象不一样
      ```
      
      ------
      
      

2. 饿汉式

   ```java
   package com.cbl.single;
   
   /**
    * @author ：CBL
    * @date ：Created in 2020/1/9  21:41
    * @description：
    */
   public class HungrySingle {
   
       /**
        * 私有化构造方法
        */
       private HungrySingle(){
   
       }
       /**
        * 在加载类的时候，直接欸创建这个对象
        */
       private static   HungrySingle hungrySingle=new HungrySingle();
   
       /**
        * 对外提供获取对象的方法
        * @return
        */
       public static  HungrySingle getHungrySingle(){
           return hungrySingle;
       }
   }
   ```

   - 优点：在不使用反射的情况下，可以保证对象的唯一。
   - 缺点：对象是在系统启动的时候创建的，假如对象创建需要消耗很大的资源会导致系统启动过慢。而且反射可以创建对象。

3. 双重锁校验

   ```java
   package com.cbl.single;
   
   /**
    * @author ：CBL
    * @date ：Created in 2020/1/12  15:51
    * @description：
    */
   public class DoubleLockSingle {
   
   
       /**
        * 私有化构造方法
        */
       private DoubleLockSingle() {
       }
   
   
       /**
        * 私有的对象
        */
       private  static volatile DoubleLockSingle doubleLockSingle=null;
   
   
       /**
        * @Description: 双重锁校验获取
        * @param:
        * @return: com.cbl.single.DoubleLockSingle
        * @Author: CBL
        * @Date: 2020/1/12 16:00
        */
       public static DoubleLockSingle getDoubleLockSingle(){
           /**
            * 判断是否已经创建了对象，假如不为空，直接返回
            */
           if (doubleLockSingle==null){
               /**
                * 加锁，一次只能一个线程去访问
                */
               synchronized (DoubleLockSingle.class){
                   /**
                    * 假如这里不判断,那么会出现下线这种情况：
                    * 假如有两个线程，A线程执行完第一个判断是否为空，检测到为空，发现同步代码块里锁还					   没有释放，A线程进入线程等待.
                    * B线程已经在创建对象的过程中，那么等B线程执行完之后，A线程也会去创建对象，会导致				   创建了
                    * 所以里面必须要加个判断。
                    * 即使这样，双重校验锁也是有问题的，因为创建对象不是一步原子操作，而是分为三步
                    * 1.分配对象的内存空间
                    * 2.初始化对象，调用构造方法
                    * 3.将内存地址指向instance
                    * 而且2，3可能会重新排序，即创建对象的步骤可能是1-2-3，也有可能是1-3-2
                    * 假如是1-3-2
                    * B线程创建独享执行到3，此时对象不为空了，但是还没有初始化对象，调用构造方法
                    * 此时A线程在第一个判断的时候，判断了对象不为空，直接返回，这个时候返回的对象就会					   有问题。
                    * 所以对象用volatile修饰，可以保证对象创建的原子性.
                    */
                   if (doubleLockSingle==null){
                       doubleLockSingle=new DoubleLockSingle();
                   }
               }
           }
           return doubleLockSingle;
       }
   
   }
   
   ```

   

4. 静态内部类

   ```java
   package com.cbl.single;
   
   /**
    * @author ：CBL
    * @date ：Created in 2020/1/13  10:41
    * @description： 内部类单例模式
    */
   public class InternalClassSingle {
   
   
       /**
        * 私有化构造方法
        */
       private InternalClassSingle() {
       }
   
       /**
        * 通过静态内部类创建一个对象
        * 在使用时才加载。不过在加载静态内部类的过程中也会加载外部类，相比于懒汉式来说，不需要再系统启动的时候去创建对象
        */
       private static class  Single{
           private static  InternalClassSingle INTERNAL_CLASS_SINGLE=new InternalClassSingle();
       }
   
   
       /**
        * 提供对外方法
        * @return
        */
       public InternalClassSingle getInterClassSingle(){
           return Single.INTERNAL_CLASS_SINGLE;
       }
   }
   ```

   

5. 枚举

   ```java
   package com.cbl.single;
   
/**
    * @author ：CBL
    * @date ：Created in 2020/1/13  11:23
    * @description：
    */
   public class EnumSingle {
   
       private EnumSingle enumSingle;
   
   
           static enum SingletonEnum{
   
           /**
            * 创建一个枚举对象，该对象天生为单例
            */
           INSTANCE;
           private EnumSingle enumSingle;
   
           /**
            * 私有化构造方法
            */
           private  SingletonEnum(){
               enumSingle=new EnumSingle();
           }
           public  EnumSingle getEnumSingle(){
               return enumSingle;
           }
       }
   
       public static EnumSingle getSingle(){
             return SingletonEnum.INSTANCE.getEnumSingle();
       }
   }
   ```
   
   **推荐使用枚举，反射也无法实例化对象。**